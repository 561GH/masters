# Testing functions

## testing g(.)
```{r}
lambda <- 5/2
l <- 1
ltrans <- sqrt(2 * lambda) / l
xik <- 3
xjk <- 11
# see comments in r(., .)
```

## tests for covMatrix()
```{r}
## n > 2
set.seed(761)
n <- 3
X <- matrix(rnorm(n^2), ncol = n)
sig2 <- 1
l <- rep(1, n)

## before creating covar.fun argument
# test <- covMatrix(X = X, sig2 = sig2, l = l)
# test
#              [,1]         [,2]         [,3]
# [1,] 1.000000e+00 2.259359e-02 3.853816e-05
# [2,] 2.259359e-02 1.000000e+00 9.133891e-08
# [3,] 3.853816e-05 9.133891e-08 1.000000e+00

## after creating covar.fun argument
covMatrix(X = X, sig2 = sig2, covar.fun = r.matern, l = l)
#              [,1]         [,2]         [,3]
# [1,] 1.000000e+00 2.259359e-02 3.853816e-05
# [2,] 2.259359e-02 1.000000e+00 9.133891e-08
# [3,] 3.853816e-05 9.133891e-08 1.000000e+00

covMatrix(X = X, sig2 = sig2, covar.fun = r.matern2, l = l)
#              [,1]          [,2]          [,3]
# [1,] 1.000000e+00  3.676694e-05  9.736003e-07
# [2,] 3.676694e-05  1.000000e+00 -5.547833e-09
# [3,] 9.736003e-07 -5.547833e-09  1.000000e+00
```

```{r}
## test covMatrix with X and X2
set.seed(761)
d <- 3
n <- 3
n2 <- 5
X <- matrix(rnorm(n * d), ncol = d)
X2 <- matrix(rnorm(n2 * d), ncol = d)
sig2 <- 1
l <- rep(1, d)

Sxx2 <- covMatrix(X = X, X2 = X2, sig2 = sig2, covar.fun = r.matern, l = l)
#              [,1]         [,2]         [,3]         [,4]         [,5]
# [1,] 9.130506e-05 3.827716e-03 2.450871e-04 2.287981e-06 0.2392954302
# [2,] 2.385852e-05 1.635486e-01 5.011175e-08 8.289889e-08 0.0155601739
# [3,] 4.321343e-03 2.159767e-06 2.347978e-03 6.127628e-05 0.0006670394

check <- covMatrix(X = rbind(X, X2), sig2 = sig2, covar.fun = r.matern, l = l)
check[1:n, (d+1):ncol(check)]  # should match above 

# check transpose
Sx2x <- covMatrix(X = X2, X2 = X, sig2 = sig2, covar.fun = r.matern, l = l)
all.equal(Sxx2, t(Sx2x))

# check for derivative 
Sxx2 <- covMatrix(X = X, X2 = X2, sig2 = sig2, covar.fun = r.matern2, l = l)
#               [,1]          [,2]          [,3]          [,4]          [,5]
# [1,]  1.322868e-04 -6.318676e-03 -1.272285e-03 -3.080564e-06  0.0019702376
# [2,]  7.777405e-06  8.959285e-05 -1.650897e-06 -2.498250e-15 -0.0008204335
# [3,] -2.159726e-03  1.377969e-05 -1.882618e-04 -2.107349e-04  0.0003860288

Sx2x <- covMatrix(X = X2, X2 = X, sig2 = sig2, covar.fun = r.matern2, l = l)
```


## testing whether errors are thrown correctly
```{r}
set.seed(761)
n <- 3
X <- matrix(rnorm(n^2), ncol = n)
sig2 <- 1
l <- rep(1, n)

# no l or ltrans argument
covMatrix(X = X, sig2 = sig2, covar.fun = r.matern)  
 # Error in { : 
 #  task 1 failed - "Length scale parameter l or ltrans missing." 
# - hooray and we know exactly what's wrong due to error handling in r.matern
```



```{r}
## n = 2
set.seed(761)
n <- 2
X <- matrix(rnorm(n^2), ncol = n)
sig2 <- 1
l <- rep(1, n)

## before creating covar.fun argument
# test <- covMatrix(X = X, sig2 = sig2, l = l)
# test
#           [,1]      [,2]
# [1,] 1.0000000 0.5694542
# [2,] 0.5694542 1.0000000

## after creating covar.fun argument
covMatrix(X = X, sig2 = sig2, covar.fun = r.matern, l = l)
#           [,1]      [,2]
# [1,] 1.0000000 0.5694542
# [2,] 0.5694542 1.0000000
```

# function arguments
```{r}
tmp <- rnorm
do.call(what = tmp, args = list(n = 10, mean = 5))

tmp <- function(...) {
  do.call(what = rnorm, args = list(...))
}

tmp(n = 10, mean = 5)
```


# trying to understand the Matern covariance
```{r}
xi <- 0
xj <- seq(0, 10, length.out = 100)
covar.vals <- NULL
for (i in 1:length(xj)) {
  covar.vals <- c(covar.vals, r(xi = xi, xj = xj[i], l = 1))
}
plot(x = abs(xi - xj), y = covar.vals, pch = 16)

## squared exponential 
```

# eta0 small tests

## testing log.posterior
```{r}
post.args <- list(l = 5.7,  # 5.7
                  sig2 = 1500,
                  ystar = ytrue(xstar),
                  yprime = 20 / (20 * xprime),
                  given = given)

do.call(logposterior, post.args)  # -6080.763
```

```{r}
l <- 15
sig2 <- 1
ystar <- ytrue(xstar)
yprime <- 20 / (20 * xprime)
given <- given
```


